############################################################
#        多国語文字の扱い   	    	 		   #
############################################################

1. 文字の種類

	'Type n-m' は、オリジナルnバイトのコードをmバイトで表現するの意。

  Type 1-1: ASCII 文字
  Type 1-2: ASCII 以外の 1バイト文字 (e.g. ISO8859-1, Latin-1)
  Type 1-3: プライベートに使用する 1バイト文字
  Type 2-3: 2バイト文字 (e.g. JISX0208, Japanese)
  Type 2-4: プライベートに使用する 2バイト文字
  Type 3-4: 3バイト文字
  Type N:   不定長の合成文字(composite character)

夫々の文字集合はISO2022の技術要求を満たすと仮定する。


2. バッファ及び文字列中での文字表現

  Type 1-1: 1バイトの 'C' [C <= 0x7F] (以前のGNU Emacs, Nemacsと同じ)
  Type 1-2: 2バイトの列 'LC1 C1'
	LC1 = 夫々の文字集合のリーディング・キャラクタ
		0x81 <= LC1 <= 0x8F
        C1 = 0x80 | (文字本来のバイト値)
		0xA0 <= C1 <= 0xFF
  Type 1-3: 3バイトの列 'LCPRV1 LC12 C1'
	LCPRV1 = リーディング・キャラクタ 0x9A (表示1桁用) or 0x9B (表示2桁用)
	LC12 = 拡張リーディング・キャラクタ
		0xA0 <= LC12 <=0xB7 (LCPRV1 = 0x9Aの時) -- 計24集合分
		0xB8 <= LC12 <=0xBF (LCPRV1 = 0x9Bの時) -- 計8集合分
	C1 = Type 1-2同様
  Type 2-3: 3バイトの列 'LC2 C21 C22'
	LC2 = リーディング・キャラクタ
		0x90 <= LC2 <= 0x99
	C21 = 0x80 | (文字本来の第1バイト値)
	C22 = 0x80 | (文字本来の第2バイト値)
		0xA0 <= C21,C22 <= 0xFF
  Type 2-4: 4バイトの列 'LCPRV2 LC22 C21 C22'
	LCPRV2 = リーディング・キャラクタ 0x9C (表示1桁用) or 0x9D (表示2桁用)
	LC22 = 拡張リーディング・キャラクタ
		0xC0 <= LC22 <=0xC7 (LCPRV2 = 0x9Cの時) -- 計8集合分
		0xC8 <= LC22 <=0xDF (LCPRV2 = 0x9Dの時) -- 計24集合分
	C21, C22 = Type 2-3同様
  Type 3-4: 4バイトの列 'LC3 C31 C32 C33'
	LC3 = リーディング・キャラクタ
		LCPRV3 = 0x9E
	C31 = 0x80 | (文字本来の第1バイト値)
		0xA0 <= C31 <= 0xBF
	C32 = 0x80 | (文字本来の第2バイト値)
	C33 = 0x80 | (文字本来の第3バイト値)
		0xA0 <= C32,C33 <= 0xFF
  Type N: nバイトの列 'LCCMP LCN1 C11 ... LCN2 C21 ... LCNn Cn1 ...'
	全文字 'LCN1 C11 ... LCN2 C21 ... LCNN CN1 ...'
	を、同一桁に表示する
	LCCMP = 0x80
	LCN1 .. LCNN = リーディング・キャラクタ値 + 0x20
    	    	    	ASCIIは 0xA0

定義済みのリーディング・キャラクタについては、セクション5を参照のこと。

これらのタイプの混合テキストの例。
(0x?? と書いたところは、実際はそのバイナリ・コードが入る)

"Here comes Latin-1 character of n with ~ '0x81 0xF1' and
here comes Japanese Hiragana '0x92 0xA4 0xA2'."


3. Emacs Lispでの文字オブジェクトの表現

Emacs Lispは文字オブジェクトを256未満の整数値として扱う。
そこで、文字オブジェクトを次のように拡張する:

Type 1-1: `C' (`C' は 0x7f以下)
     0 ... 0x7F, キャラクタコードそのものと同じ。
Type 1-2: ((LC1 - 0x80) << 8) | C1
     0x01A0 ... 0x0FFF
Type 1-3: ((LC21 - 0x80) << 8) | C1
     0x20A0 ... 0x3FFF
Type 2-3: ((LC2 - 0x80) << 16) | (C21 << 8) | C22
     0x10A0A0 ... 0x19FFFF
Type 2-4: ((LC22 - 0x80) << 16) | (C21 << 8) | C22
     0x40A0A0 ... 0x5FFFFF
Type 3-4: ((C31 - 0x40 << 16) | (C32 << 8) | C33
     0x60A0A0 ... 0x7FFFFF
Type N:
     文字オブジェクトとしては扱えない

例えば、`?' の後に Type1-2 の文字 0x81 0xF1 がある場合、その値は 498 ( =
((0x81 & 0x1F) << 8) | 0xF1) になる。

上記の表中で、ブロックの幾つかは定義していない。
これらは部分的に定義した文字を表現するために、内部的に使用している:
  0x80 .. 0xFF: リーディング・キャラクタのみ或は無効文字
  0x10A000 .. 0x19FF00: Type 2-3のLC2 + C21
  0x200000 .. 0x3F0000: Type 1-3の(LCPRV11 or LCPRV12) + LC21
  0x400000 .. 0x5F0000: Type 2-4の(LCPRV21 or LCPRV22) + LC22
  0x40A000 .. 0x5FFF00: Type 2-4の(LCPRV21 or LCPRV22) + LC22 + C21
  0x600000 .. 0x7F0000: Type 3-4のLC3 + C31
  0x60A000 .. 0x7FFF00: Type 3-4のLC3 + C31 + C32


4. 関数

多国語文字を扱うために、次の関数を追加/拡張した。

editfns.c中では、

char-to-string: 
引数CHARをその文字の文字列に変換する。
CHAR < 0ならば、多国語文字とみなし、正しい文字列を返す。

例::
	(char-to-string ?A) => "A"
	(char-to-string ?あ) => "あ"
	(char-to-string 1221794) => "あ"

string-to-char:
引数STRINGの文字列第1文字を文字に変換

例:
	(string-to-char "ABあい") => 65 (== ?A)
	(string-to-char "あい") => 1221794 (== ?あ)

sref:
文字列STRINGの位置INDEXの文字を返す。INDEXは0から数える。
INDEXが文字境界を指さない場合、-1を返す。

例::
	(sref "ABあい" 1) => 66 (== ?b)
	(sref "ABあい" 2) => 1221794 (== ?あ)
	(sref "ABあい" 3) => -1 (non character boundary)
	(sref "ABあい" 5) => 1221796 (== ?い)

sset:
文字列STRINGの位置INDEXの位置に文字CHARを置く。
INDEXはCHARと同バイト数の文字を指すこと。
その場合CHARを返し、そうでなければnilを返す。

例::
	(setq s "ABあい")
	(sset s 1 ?C) => ?C (s == "ACあい")
	(sset s 2 ?う) => ?う (s == "ACうい")
	(sset s 2 ?A) => ?A (s == "ACA\244\246い")
	(sset s 8 ?A) => nil (範囲外)

following-char:
ポイントの次にある文字を数値として返す。
現バッファのmc-flagが非nilならば、返り値の文字は多国語文字である。

例: 	バッファ中の"..Aあ.."の'あ'にカーソルがあるならば、
        	(つまり、ポイントは'A'と'あ'との間にある)
	(following-char) => 1221794 (== ?あ)
	(let (mc-flag)
	 (following-char t)) => 146 (== ?あ のリーディング・キャラクタ)

preceding-char:
ポイントの前にある文字を数値として返す。
現バッファのmc-flagが非nilならば、返り値の文字は多国語文字である。

例: 	バッファ中の"..あA.."の'A'にカーソルがあるならば、
	(preceding-char) => 1221794 (== ?あ)
	(let (mc-flag)
	  (preceding-char t)) => 162 (== ?あ の最終バイト値)

char-after
第1引数POSは数値。現バッファ位置POSの文字を返す。
POSが範囲外なら、nilを返す。
現バッファのmc-flagが非nilならば、返り値の文字は多国語文字である。

関数'insert'と'insert-char'もやはり多国語文字に大して正しく動作する。

	(insert ?あ) -- ポイントの位置に"あ"を挿入


buffer-substring:
現バッファの一部の内容を文字列として返す。
2つの引数はその領域の開始/終了位置を表す数値。
現バッファのmc-flagが非nilならば、
領域は多国語文字境界に見合うように拡大される。

例: バッファが"あいう..."という内容で始まるならば、
	(buffer-substring 1 2) => "あ"
	(buffer-substring 1 3) => "あ"
	(buffer-substring 2 4) => "あい"

他の「領域(region)」を扱う関数も、範囲を自動的に拡大する。


subst-char-in-region:
STARTからENDまで、FROMCHARが現れる度にTOCHARで置き換える。
オプション引数NOUNDOが非nilならば、アンドゥのための記録もしないし、
バッファ修正のマークもしない。
置換がバッファ長を変えない場合に限り、多国語文字についてもうまく動作する。

例:
	(subst-char-in-region 1 10 ?a ?b) => 可
	(subst-char-in-region 1 10 ?あ ?い) => 可
	(subst-char-in-region 1 10 ?a ?あ) => 不可

関数'message' と 'format'では、 %c は多国語文字に対しても正しく動作する。

	(message "%c" ?あ) -- エコー領域に"あ"と表示

mule.c 中では、

make-character:
LEADING-CHARとオプション引数ARG1, ARG2, ARG3から、多バイト文字を作る。
LEADING-CHARはリーディング・キャラクタ或は拡張リーディング・キャラクタ。

例:
	(make-character lc-jp ?\244 ?\242) => 1221794 (== ?あ)

char-component:
多国語文字CHARの要素を返す。
第2引数IDXは、次のどの要素を返すべきかを示す。
 0: リーディング・キャラクタ或は拡張リーディング・キャラクタ
 1: 文字コードの第1バイト
 2: 文字コードの第2バイト
 3: 文字コードの第3バイト
指定した要素をCHARが持たない場合、0を返す。

例:
	(char-component ?あ 0) => 146 (== lc-jp)
	(char-component ?あ 1) => 164
	(char-component ?あ 2) => 162
	(char-component ?A 1)  => 0

char-leading-char:
CHARのリーディング・キャラクタを返す。
CHARが多国語文字でなければ、0を返す。

例:
	(char-leading-char ?あ) => 146 (== lc-jp)
	(char-leading-char ?A) => 0

char-bytes:
CHARがバッファ内で占めるバイト数を返す。
CHARにリーディング・キャラクタを与えれば、
その文字集合について調べることになる。

例:
	(char-bytes ?あ) => 3
	(char-bytes ?A) => 1
	(char-bytes lc-jp) => 3

char-width:
CHARが表示何桁を占めるかを返す。
CHARにリーディング・キャラクタを与えれば、
その文字集合について調べることになる。

例:
	(char-width ?あ) => 2
	(char-width ?A) => 1
	(char-width lc-jp) => 2

chars-in-string:
STRING中の文字数を返す。
各多国語文字を1と数える。

例:
	(chars-in-string "ABあい") => 4

char-boundary-p:
POSが文字境界にあるならば、非nil値を返す。
その値は:
 0: POSがASCII文字にあるか、範囲終端にある場合
 1: POSが2バイト文字のリーディング・キャラクタにある場合
 2: POSが3バイト文字のリーディング・キャラクタにある場合
POSが文字境界に無い場合、或は範囲外にある場合、nilを返す。


5. 文字集合

文字集合: ASCII, ISO8859-1右側, JISX0208等
    文字集合は各集合固有に割り当てたリーディング・キャラクタで識別する。

各文字集合は、次の属性によって特徴づけされる:
    1. コードのバイト長: 1バイト或は2バイト
	ISO8859-1, JISX0201右側 (日本語カタカナ) -- 1バイト
	GB2312-1980 (中国語), JISX0208 (日本語) -- 2バイト
    2. 表示桁数: 1桁或は2桁
	ISO8859-1, JISX0201右側 (日本語カタカナ) -- 1桁
	GB2312-1980 (中国語), JISX0208 (日本語) -- 2桁
    3. 種類: 94文字集合, 96文字集合, 94×94文字集合, 或は 96×96文字集合
    4. 図形集合: GL 或は GR
    5. 最終文字: '0' 〜 '~'のうちの1つ
    6. 表示方向: 左から右、或は右から左
    7. リーディング・キャラクタ: Muleシステムが1つづつ割り当てる

3〜5は、ISO2022の記法。

文字集合は'new-character-set'関数呼出で定義する。

--- mule.c ---------------------------------------------------------
## Function: new-character-set
    新しい第1引数LEADING-CHARの文字集合を定義する。
    残りの引数:
    	BYTE: 1, 2, または 3
    	COLUMNS: 1 または 2
    	TYPE: 0 (94文字集合), 1 (96文字集合),
    	    	2 (94×94文字集合), または 3 (96×96 文字集合)
    	GRAPHIC: 0 (出力にG0使用) または 1 (出力にG1使用)
    	FINAL: ISOエスケープ・シーケンスの最終文字
    	DIRECTION: 0 (左から右) or 1 (右から左)
    	DOC: 説明文字列
LEADING-CHAR >= 0xA0ならば、拡張リーディング・キャラクタとみなし、
引数BYTE と COLUMNS は無視する。
------------------------------------------------------------

Muleシステムは、以下の文字集合を予め定義する。

--- mule.el ---------------------------------------------------------
(defconst *predefined-character-set*
  (list
   ;; (cons lc '(bytes width type graphic final direction doc))
   ;; (cons lc-ascii '(0 1 0 0 ?B 0 "ASCII")) ;; Predefined in C file
   (cons lc-ltn1 '(1 1 1 1 ?A 0 "ISO8859-1 Latin-1"))
   (cons lc-ltn2 '(1 1 1 1 ?B 0 "ISO8859-2 Latin-2"))
   (cons lc-ltn3 '(1 1 1 1 ?C 0 "ISO8859-3 Latin-3"))
   (cons lc-ltn4 '(1 1 1 1 ?D 0 "ISO8859-4 Latin-4"))
   (cons lc-grk '(1 1 1 1 ?F 0 "ISO8859-7 Greek"))
   (cons lc-arb '(1 1 1 1 ?G 1 "ISO8859-6 Arabic"))
   (cons lc-hbw '(1 1 1 1 ?H 1 "ISO8859-8 Hebrew"))
   (cons lc-kana '(1 1 0 1 ?I 0 "JIS X0201 Japanese Katakana"))
   (cons lc-roman '(1 1 0 0 ?J 0 "JIS X0201 Japanese Roman"))
   (cons lc-crl '(1 1 1 1 ?L 0 "ISO8859-5 Cyrillic"))
   (cons lc-ltn5 '(1 1 1 1 ?M 0 "ISO8859-9 Latin-5"))
   (cons lc-jpold '(2 2 2 0 ?@ 0 "JIS X0208-1976 Japanese Old"))
   (cons lc-cn '(2 2 2 0 ?A 0 "GB 2312-1980 Chinese"))
   (cons lc-jp '(2 2 2 0 ?B 0 "JIS X0208 Japanese"))
   (cons lc-kr '(2 2 2 0 ?C 0 "KS C5601-1987 Korean"))
   (cons lc-jp2 '(2 2 2 0 ?D 0 "JIS X0212 Japanese Supplement"))
   (cons lc-big5-1 '(2 2 2 0 ?0 0 "Big5 Level 1"))
   (cons lc-big5-2 '(2 2 2 0 ?1 0 "Big5 Level 2"))))

(let ((c *predefined-character-set*)
      lc data)
  (while c
    (setq lc (car (car c))
	  data (cdr (car c)))
    (apply 'new-character-set lc data)
    (setq c (cdr c))))

更に、以下のプライベート文字集合を予め定義する。
--- mule-config.el -----------------------------------------
;; REGISTRATION OF PRIVATE CHARACTER SETS

;; PinYin-ZhuYin
(setq lc-sisheng (new-private-character-set 1 1 0 0 ?0 0 "PinYin-ZhuYin"))

;; Thai TSCII
(setq lc-thai (new-private-character-set 1 1 0 0 ?1 0 "Thai TSCII"))

;; Vietnamese VISCII with two tables.
(setq lc-vn-1 (new-private-character-set 1 1 1 1 ?1 0 "VISCII lower"))
(setq lc-vn-2 (new-private-character-set 1 1 1 1 ?2 0 "VISCII upper"))
------------------------------------------------------------

変数lc-asciiからlc-big5-2もやはり以下のように予め定義する。

/** The followings are for 1-byte characters. **/
lc-ascii = 0x00		/* Omitted in a buffer */
lc-ltn1	= 0x81		/* Right half of ISO 8859-n */
lc-ltn2	= 0x82		/*  */
lc-ltn3	= 0x83		/*  */
lc-ltn4	= 0x84		/*  */
	  0x85		/* for future use */
lc-grk	= 0x86		/*  */
lc-arb	= 0x87		/*  */
lc-hbw	= 0x88		/*  */
lc-kana	= 0x89		/* Right half of JIS X0201-1976 */
lc-roman = 0x8A		/* Left half of JIS X0201-1976 */
	  0x8B		/* for future use */
lc-crl	= 0x8C		/* Right half of ISO 8859-5 */
lc-ltn5	= 0x8D		/*  */
	  0x8E		/* for future use */
	  0x8F		/* for future use */

/** The followings are for 2-byte characters. **/
lc-jpold = 0x90		/* For Japanese JIS X0208-1976 */
lc-cn	= 0x91		/* For Chinese Hanzi GB2312-1980 */
lc-jp	= 0x92		/* For Japanese JIS X0208-1983 */
lc-kr	= 0x93		/* For Hangul KS C5601-1987 */
lc-jp2	= 0x94		/* For Japanese JIS X0212-1990 */
lc-cns1	= 0x95		/* For Chinese CNS11643 Set 1 */
lc-cns2	= 0x96		/* For Chinese CNS11643 Set 2 */
	  0x97		/* for future use */
lc-big5-1 = 0x98	/* For Big5 Level 1 */
lc-big5-2 = 0x99	/* For Big5 Level 2 */
lc-prv11 = 0x9A
lc-prv12 = 0x9B
lc-prv21 = 0x9C
lc-prv22 = 0x9D
lc-prv3 = 0x9E

/** The followings are only for internal use **/
lc-cmp = 0x80		/* For composite character */
lc-invalid = 0x9F
